/**
 * List coursework in a course by topic. WARNING, this function won't include
 *  first level materials elements as as of Oct 19 is not yet exposed in Classroom API
 *  (See https://b.corp.google.com/issues/115421140)
 * @param TopicID The topic id for the topic in the course
 * @param courseID the course ID
 */
function listCourseworkByTopic(TopicID: string, courseID: string):GoogleAppsScript.Classroom.Schema.CourseWork[]  {
  
  let courseworkList:GoogleAppsScript.Classroom.Schema.CourseWork[] = [];
  let pageToken: string, page: GoogleAppsScript.Classroom.Schema.ListCourseWorkResponse;
  do {
    page = Classroom.Courses.CourseWork.list(courseID);
    page.courseWork.forEach(coursework => {
      // Coursework type does not yet include the topicId property, Typescript
      // will complain about it
      if (coursework.topicId === TopicID) {
        console.log(`Detected coursework ${coursework.title} for topic ID ${TopicID}`);
        courseworkList.push(coursework);
      }
    });
    pageToken = page.nextPageToken;
  } while(pageToken);
  return courseworkList;
}


/**
 * Replicates a topic with all its coursework artifacts
 * @param srcCourseID
 * @param destCourseID
 */
function replicateTopics({ srcCourseID, destCourseID }: { srcCourseID: string; destCourseID: string; }) {

  // Topics is not yet included in Classroom typing, Typescript will complain about this
  let topicsListObj = Classroom.Courses.Topics.list(srcCourseID);
  let topicsList = topicsListObj.topic;
  let result = [];
  result = topicsList.map(topic => {
    let topicResource = {
      "name": topic.name
    };
    let response = Classroom.Courses.Topics.create(topicResource, destCourseID);
    result.push({"name": response.name, 
      "topicId":response.topicId});
  });
}


/**
 * Replicates coursework from an existing course with topics and coursework to an empty course
 * @param srcCourseID 
 * @param destCourseID 
 */
function replicateCourseWork({ srcCourseID, destCourseID }: { srcCourseID: string; destCourseID: string; }) {

  let topicsListObj = Classroom.Courses.Topics.list(srcCourseID);
  let topicsList = topicsListObj.topic;
  // Iterate topics in original course
  topicsList.map(topic => {
    let topicResource = {
      "name": topic.name
    };
    // Create new topics in new course with same name, get back new topicIds
    let newTopic = Classroom.Courses.Topics.create(topicResource, destCourseID);
    let newTopicId = newTopic.topicId;
    // Get coursework for each topic in the original course
    let courseworkArray = listCourseworkByTopic(newTopicId,srcCourseID );
    courseworkArray.map(coursework => {
      let newCourseworkResource = cleanCoursework(coursework);
      newCourseworkResource.topicId = newTopicId;
      // Replicate course work in the topic replica in the destination course
      Classroom.Courses.CourseWork.create(newCourseworkResource, destCourseID);
    });
  });
}

/**
 * Cleans coursework from autogenerated attributes that won't be accepted when
 *  creating a new coursework artifact
 * @param coursework 
 * @returns cleaned coursework object
 */
function cleanCoursework(coursework) {
  
  let extraOpts = ['creatorUserId','creationTime','alternateLink','updateTime','id','courseId','state'];
  for (let index in extraOpts) {
    delete coursework[extraOpts[index]];
  }
  return coursework;
}


/**
 * Grabs active courses list and stores the ids in an array
 * @returns Array containing list of active courses in Classroom
 */
function listCourses() {
  
  let optionalArgs = {
    courseStates: 'ACTIVE'
  };
  let response = Classroom.Courses.list(optionalArgs);
  let courses = response.courses;
  if (courses && courses.length > 0) {
    return courses.map(course => course.id);
  }
  
}

/**
 * Adds a user to a set of courses defined in the main user info sheet
 * @param userData 
 * @returns list of courses the user has been subscribed to
 */
function addUserToCourses(userData: string[]): string {
  
  let trackNames = userData[idxOf.track];
  // Extract 2nd column from 2d array
  let courseIDsArray = trackToIDArray.map(element => element[1]);
  console.log(`addUserToCourses(): got courseIDsArray ${courseIDsArray}`);
  //let result: string[];
  //let message: string;
  // Track field maybe multivalued (comma separated)
  return trackNames.split(',').map(function (element) {
    //Get the ID from the name
    let courseID: string = trackToID[element];
    console.log(`addUserToCourses(): ${element} track ID is ${courseID}`);
    // Check that the class exists
    if (courseIDsArray.indexOf(courseID) > -1) {
      console.log(`addUserToCourses(): Adding
        ${userData[idxOf.GSuiteEmail]} to course ${courseID}`);
      let studentObject = {
        "userId": userData[idxOf.GSuiteEmail]
      };
      try {
        Classroom.Courses.Students.create(studentObject,courseID.toString());
        return `${element}: REGISTERED`;
      } catch(err) {
        console.error('Error while adding %s to course %s: %s',userData[idxOf.GSuiteEmail]
        ,courseID,err);
        return `${element}: ERROR`
      }
    }
  }).join();
}


/**
 * Remove the user from subscribed courses
 * @param userData 
 */
function removeUserFromCourses(userData: string[], courseStudents:object) {
  // TODO Rewrite: this function should first check all
  // for the user, then unsubscribe him from all of them.
  let identity = userData[idxOf.GSuiteEmail];
  let courseNames = checkCourses(identity, courseStudents);
  return courseNames.split(',').map(courseName => {
    //Get the ID from the name
    let courseID = trackToID[courseName].toString();
    try {
      Classroom.Courses.Students.remove(courseID, identity);
      return `${courseName}: UNREGISTERED`
    } catch(e) {
      console.error(`Error while removing ${identity} from course ${courseID}: ${e}`);
      return `${courseName}: ERROR`;
    }
  }).join();
}

/**
 * Check the course a user (identity) belongs to
 * @param identity 
 * @param courseStudents 
 */
function checkCourses(identity: string, courseStudents):string {
  
  var result = [];
  // Run though the different course IDs
  for (var track in trackToID) {
    if (contains(courseStudents[trackToID[track]],identity.toLowerCase())) {
      result.push(track);
    }
  }
  return result.join();
}

/**
 * Gets a list of all students for all courses in the domain
 * @returns Returns an object 
 */
function listStudents(): object {
  
  // Object to store rows: courses, colums:students
  // List properties we're expecting
  let courseStudents : {} = {};
  let courseIDs = listCourses();
  if (courseIDs && courseIDs.length > 0) {
    courseIDs.forEach(courseID => {
      let studentsArray = [];
      let pageToken: any, page: any;
      do {
        // Compose object passing the pageToken
        // Do not bother passing maxResults, Classroom returns
        // whatever it wants anyway.
        let queryParams = {
          pageToken: pageToken
        };
        // Correct way to invoke method is pathParameters, queryParameters
        page = Classroom.Courses.Students.list(courseID, queryParams);
        let students = page.students;
        if (students && students.length > 0) {
          students.forEach((student: { profile: { emailAddress: any; }; }) => {
            //Watch out, Classroom ID is not the email address
            //console.log('listStudents(): processing studentId %s', student.profile.emailAddress);
            studentsArray.push(student.profile.emailAddress);
            //console.log('listStudents(): studentsArray is ', studentsArray);
          });
        }
        pageToken = page.nextPageToken;
      } while(pageToken);
      courseStudents[courseID] = studentsArray;
    });
  } else {
    console.log('No courses found.');
  }
  console.log('listStudents(): The object courseToStudents is ', courseStudents);
  return courseStudents;
}

function exportCourseToGDoc(courseID: string, exportDocTemplateID: string) {
  
  // Create the export folder
  let exportFolder = createFolderFromPathName(mainConfObj.mainExportFolder);
  console.log(`Export folder is ${exportFolder}`);
  // Give anyone with the link outside the domain permissions to see the folder
  exportFolder.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

  // Get the course name and define the export Doc variable
  const courseName = Classroom.Courses.get(courseID).name;
  let exportDoc: GoogleAppsScript.Document.Document;
  
  // Create GDoc to export, or use existing template
  if (exportDocTemplateID) {
    // Copy the template and change the name
    let newDocID = DriveApp.getFileById(exportDocTemplateID).makeCopy(courseName).getId();
    exportDoc = DocumentApp.openById(newDocID).setName(courseName);
  } else {
    //Create a new document
    exportDoc = DocumentApp.create(courseName).setName(courseName);
  }

  // Get the export Doc Drive File
  let exportDocFile = DriveApp.getFileById(exportDoc.getId());

  // Set the document title
  let docBody = exportDoc.getBody();
  //docBody.appendParagraph(courseName).setHeading(DocumentApp.ParagraphHeading.TITLE);
  docBody.replaceText('\%Title\%', courseName);

  // Set the document footer
  let docFooter = exportDoc.getFooter();
  docFooter.replaceText('\%Customer\%',`Google Cloud Days for ${mainConfObj.customerName}`);

  // Move the export Doc to the export folder
  exportDocFile.getParents().next().removeFile(exportDocFile);
  exportFolder.addFile(exportDocFile);

  // Get the topics, these should be H1 sections in the exported Doc
  let topicsListObj = Classroom.Courses.Topics.list(courseID);
  let topicsList = topicsListObj.topic;
  
  // Iterate the topics
  // TODO: there's no ordering specified, we should follow the order in the UI
  topicsList.map(topic => {
    let topicTitle =  topic.name;
    // Create heading for the topic title in Google Doc
    docBody.appendParagraph(topicTitle).setHeading(DocumentApp.ParagraphHeading.HEADING1);
    // Get coursework for each topic in the course
    let courseworkList: GoogleAppsScript.Classroom.Schema.CourseWork[] = listCourseworkByTopic(topic.topicId, courseID);

    courseworkList.map(coursework => {
      if (coursework.workType === 'ASSIGNMENT') {
        docBody.appendParagraph(coursework.title).setHeading(DocumentApp.ParagraphHeading.HEADING2);
        docBody.appendParagraph(coursework.description);
        let courseworkMats = coursework.materials;
        
        // Check if coursework has any materials
        if (courseworkMats === undefined || courseworkMats.length == 0) {
          console.log('No materials to add');
        } else {
          courseworkMats.map(material => {
            if (material.hasOwnProperty('link')) {
              docBody.appendParagraph(material.link.title).setLinkUrl(material.link.url);
            } else if (material.hasOwnProperty('driveFile')) {
              // Move the document to the exportFolder so it is shared with the attendees
              let extraFilesFolder = exportFolder.createFolder('Extras');
              extraFilesFolder.addFile(DriveApp.getFileById(material.driveFile.driveFile.id));
              // Add the classwork information to the document
              docBody.appendParagraph(material.driveFile.driveFile.title).setLinkUrl(material.driveFile.driveFile.alternateLink);
            }
          });
        } 
      }
    });
  });
}